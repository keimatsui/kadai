# -*- coding: utf-8 -*-
require 'nokogiri'
require 'open-uri'    http/ftp に簡単にアクセスするためのクラス
ロードパスからファイルを探してくる
拡張ライブラリもロードできる
拡張子.rb/.soを省略できる
同じファイルは二度以上ロードしない




def メソッド名(引数1, 引数2, ...)
  実行する処理
  実行する処理
end
メソッドの定義は「def」から開始し「end」までとなります。メソッドは複数定義することができますので、識別するためのメソッド名を指定します。
メソッド名を指定する場合は次の規則に従って下さい。

1) 1文字目は英文字かアンダーバー(_)
2) 2文字目以降は英数文字、アンダーバー
変数名などと異なり大文字の英文字で開始することも可能です。ただし大文字で開始するのはお勧めはできません。
(他にも記号「+,-,*,/」が使われたメソッドなどもあり、ユーザーが再定義することも実際には可能です。ここではあまり詳しく見ていきません)。

またメソッドを呼び出す時には引数を指定することが可能です。
引数を使用する場合はメソッド名の後の括弧()内に引数名をカンマ(,)で区切って続けて記述します。括弧は省略可能です。


定義されたメソッドを呼び出すと、処理がメソッド内に移りメソッド内に記述された処理が実行されます。
そしてメソッドの最後まで処理が終わると、メソッドを呼び出した次の行へ処理が戻ります。

メソッドを呼び出す時の書式は次の通りです。

オブジェクト.メソッド名(引数1, 引数2, ...)
メソッドはクラス内で定義され、そのクラスから作成されるオブジェクト(レシーバーと呼ばれます)に対して行わせたい処理を記述するものです。
その為、メソッドを呼び出す時には対象となるオブジェクトと実行させるメソッド名を指定して呼び出します。

def get_nokogiri_doc(url)
	begin
		html = open(url)
	rescue OpenURI::HTTPError
		return
	end
	Nokogiri::HTML(html.read, nil, 'utf-8')
end

例外が発生するたびに実行を中断するのではなく、致命的な例外でなければプログラムの実行を継続する、
または特別な処理を行わせたい場合もあるでしょう。このような場合にこそ、例外処理が役に立つのです。
Ruby では、発生した例外を捕まえるのに begin 文を使います。begin 文の構文を図 1 に示します。

begin
  処理A
rescue [ExceptionType, ...]
  処理B
else
  処理C
end

図 1 : 例外処理
begin 文は、そのあとに定義されている処理 A を実行します。
処理 A が正常に終了した場合、else 節が定義されていればそれを実行して end 以降の処理を継続します。
もしも、処理 A で例外が発生した場合、処理 A の実行は中断され、その例外が rescue 節で指定した例外と一致すれば、
その rescue 節を実行します。

rescue 節には配列で複数の例外を指定することができます。また、begin 文には複数の rescue 節を指定することができます。
Ruby の場合、例外は Exception というクラスとして定義されています。
例外クラスは階層構造になっていて、すべての例外クラスは直接または間接的に Exception を継承しています。
したがって、rescue 節に Exception を指定すれば、あらゆる例外を捕捉することができます。

なお、rescue 節でクラスを指定しないと、StandardError を指定したことになります。
一般的な例外クラスは StandardError のサブクラスとして定義されているので、これで一般的な例外を捕捉することができます。

たとえば、0 で割ったときには例外 ZeroDivisionError が送出されますが、これはスーパークラス StandardError で捕まえることができます。
逆に、rescue 節に ZeroDivisionError を指定すれば、それ以外のエラーは捕捉されません。


def has_next_page?(doc)
	doc.xpath("//*[@id='main']/ul/a").each {|element|
		return true if element.text == "次へ"
	}
	return false
end

def get_daily_data(doc)
	doc.xpath("//table[@class='boardFin yjSt marB6']/tr").each {|element|
		# 日付行および株式分割告知を回避
		if element.children[0].text != "日付" && element.children[1][:class] != "through"

		# 日付
		day = element.children[0].text

		# 始値
		open_price = element.children[1].text

		# 高値
		hight_price = element.children[2].text

		# 安値
		low_price = element.children[3].text

		# 終値
		closing_price = element.children[4].text

		# 出来高
		volume = element.children[5].text.gsub(/,/,'')

		puts "#{day},#{open_price},#{hight_price},
			#{low_price},#{closing_price},#{volume}"
		end
	}
end

# 証券コード
code="4689"

# 検索日
day=Time.now
ey=day.year
em=day.month
ed=day.day
start_url="http://info.finance.yahoo.co.jp/history/?sy=1900&sm=1&sd=1&ey=#{ey}&em=#{em}&ed=#{ed}&tm=d&code=#{code}"
num=1
puts "日付,始値,高値,安値,終値,出来高"
loop {
	url = "#{start_url}&p=#{num}"
	doc = get_nokogiri_doc(url)
	get_daily_data(doc)
	break if !has_next_page?(doc)
	num = num+1
}
